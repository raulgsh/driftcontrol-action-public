// Helper function to generate comment body
async function generateCommentBody(driftResults, isOverride) {
  const severityEmojis = {
    high: 'üî¥',
    medium: 'üü°', 
    low: 'üü¢'
  };
  
  let comment = '<!-- driftcontrol:comment -->\n';
  comment += '## üîç DriftControl Analysis Report\n\n';
  
  if (isOverride) {
    comment += '> ‚ö†Ô∏è **Policy Override Active** - Drift detected but merge allowed with audit trail.\n\n';
  }
  
  // Group results by severity
  const groupedResults = {
    high: driftResults.filter(r => r.severity === 'high'),
    medium: driftResults.filter(r => r.severity === 'medium'),
    low: driftResults.filter(r => r.severity === 'low')
  };
  
  // Add summary
  const totalIssues = driftResults.length;
  const highCount = groupedResults.high.length;
  const mediumCount = groupedResults.medium.length;
  const lowCount = groupedResults.low.length;
  
  comment += `**Summary**: ${totalIssues} drift issue${totalIssues !== 1 ? 's' : ''} detected\n`;
  if (highCount > 0) comment += `- ${severityEmojis.high} ${highCount} High severity\n`;
  if (mediumCount > 0) comment += `- ${severityEmojis.medium} ${mediumCount} Medium severity\n`;  
  if (lowCount > 0) comment += `- ${severityEmojis.low} ${lowCount} Low severity\n`;
  comment += '\n';
  
  // Add detailed results with collapsible sections for readability
  for (const severity of ['high', 'medium', 'low']) {
    const results = groupedResults[severity];
    if (results.length === 0) continue;
    
    // Make sections collapsible to improve readability
    const sectionTitle = `${severity.toUpperCase()} Severity Issues (${results.length})`;
    comment += `<details>\n<summary><strong>${severityEmojis[severity]} ${sectionTitle}</strong></summary>\n\n`;
    
    for (const result of results) {
      // Enhanced readability with better visual structure
      comment += `#### ${result.type.toUpperCase()} Drift: \`${result.file}\`\n\n`;
      
      // Show metadata in a more organized way
      const metadata = [];
      if (result.renamed) {
        metadata.push(`Renamed from \`${result.renamed.from}\``);
      }
      if (result.type === 'database' && result.tablesAnalyzed) {
        metadata.push(`Analyzed ${result.tablesAnalyzed} table(s)`);
      }
      
      if (metadata.length > 0) {
        comment += `üìã **Context**: ${metadata.join(' ‚Ä¢ ')}\n\n`;
      }
      
      // Show detailed changes with rule-based fix suggestions
      for (const change of result.changes) {
        comment += `- ${change}\n`;
        
        // Add rule-based fix suggestions based on change patterns
        const fixSuggestion = generateFixSuggestion(change, result.type, result.severity);
        if (fixSuggestion) {
          comment += `  üí° **Fix suggestion**: ${fixSuggestion}\n`;
        }
      }
      
      // Show transparent scoring reasoning in organized format
      if (result.reasoning && result.reasoning.length > 0) {
        comment += `\nüéØ **Risk Assessment**: ${result.reasoning.join(', ')}\n`;
      }
      
      // Show override information in prominent format if applied
      if (result.override) {
        comment += `\n‚ö†Ô∏è **Override Applied**: ${result.override.reason}\n`;
        comment += `üìÖ *Original severity: ${result.override.originalSeverity} ‚Ä¢ ${result.override.timestamp}*\n`;
      }
      
      comment += '\n';
    }
    
    // Close collapsible section
    comment += '</details>\n\n';
  }
  
  // Add override instructions if high severity
  if (highCount > 0 && !isOverride) {
    comment += '---\n';
    comment += '**Merge Blocked**: High severity drift detected. ';
    comment += 'To override this block, comment `/driftcontrol override: <reason>` on this PR.\n';
  }
  
  comment += '\n---\n';
  comment += `üìä *Analysis completed at ${new Date().toISOString()}* ‚Ä¢ Generated by [DriftControl](https://github.com/driftcontrol/action)\n`;
  
  return comment;
}

// Rule-based fix suggestion generator
function generateFixSuggestion(change, driftType, severity) {
  if (!change) {
    // Handle null/empty change string - return generic suggestion
    if (severity === 'high') {
      return 'High impact change detected. Consider phased rollout and rollback plan.';
    }
    if (severity === 'medium') {
      return 'Monitor for issues after deployment. Have rollback procedure ready.';
    }
    return null;
  }
  
  const changeUpper = change.toUpperCase();
  
  // Database drift fix suggestions
  if (driftType === 'database') {
    if (changeUpper.includes('DROP TABLE')) {
      return 'Consider backing up data before dropping tables. Use `CREATE TABLE ... AS SELECT` for data migration if needed.';
    }
    if (changeUpper.includes('DROP COLUMN')) {
      return 'Create a backup of affected data. Consider deprecating the column first before removal in a future migration.';
    }
    if (changeUpper.includes('COLUMN LOSS')) {
      return 'Review if dropped columns contain important data. Add data migration script to preserve critical information.';
    }
    if (changeUpper.includes('TYPE NARROWING')) {
      return 'Validate existing data compatibility with new type. Add data cleaning script if needed before type change.';
    }
    if (changeUpper.includes('NOT NULL')) {
      return 'Ensure all existing rows have values for this column. Add default values or data population script.';
    }
    if (changeUpper.includes('TRUNCATE TABLE')) {
      return 'Verify this is intentional data loss. Consider using DELETE with WHERE clause for selective removal.';
    }
  }
  
  // API drift fix suggestions  
  if (driftType === 'api') {
    if (changeUpper.includes('API_DELETION')) {
      return 'Notify API consumers in advance. Provide migration path to alternative endpoints.';
    }
    if (changeUpper.includes('BREAKING_CHANGE') || changeUpper.includes('REMOVED')) {
      return 'Implement API versioning (v1, v2) to maintain backward compatibility. Add deprecation notices before removal.';
    }
    if (changeUpper.includes('REQUIRED')) {
      return 'Make new required fields optional initially, then enforce in next major version. Provide default values.';
    }
    if (changeUpper.includes('MODIFIED') && severity === 'medium') {
      return 'Document API changes in changelog. Update client SDKs and example code.';
    }
  }
  
  // Infrastructure drift fix suggestions
  if (driftType === 'infrastructure') {
    if (changeUpper.includes('SECURITY_GROUP_DELETION')) {
      return 'üîí Review security implications and ensure alternative security controls are in place';
    }
    if (changeUpper.includes('SECURITY_GROUP_CHANGE')) {
      return 'üõ°Ô∏è Validate security group rules don\'t expose sensitive services to public internet';
    }
    if (changeUpper.includes('RESOURCE_DELETION')) {
      return '‚ö†Ô∏è Ensure data backup and migration strategy before deleting resources';
    }
    if (changeUpper.includes('COST_INCREASE')) {
      return 'üí∞ Review budget allocation and consider cost optimization strategies';
    }
    if (changeUpper.includes('RESOURCE_DELETION_POLICY')) {
      return 'üìã Verify deletion policy aligns with data retention requirements';
    }
  }
  
  // Generic suggestions based on severity
  if (severity === 'high') {
    return 'High impact change detected. Consider phased rollout and rollback plan.';
  }
  if (severity === 'medium') {
    return 'Monitor for issues after deployment. Have rollback procedure ready.';
  }
  
  return null; // No specific suggestion
}

module.exports = {
  generateCommentBody,
  generateFixSuggestion
};